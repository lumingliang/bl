title: 正则表达式的用法
----

###正则表达式只是一种按照人的思维的一种匹配，从那儿开始，然后拥有什么样的规则，最后又从哪里结束。一个个位置匹配下去的
<!-- 想象着整个表达式就像一个过滤器一样，对文本文件进行一个个字符的过滤，最后达到结果，既然是过滤匹配的结果也是可以多个的，有时候会将句子单词拆分开了，有时候又会得到整个句子或者词的一部分 -->
### 核心基础，元字符
[ 参考30 分钟学会正则 ](http://deerchao.net/tutorials/regex/regex.htm)
```
. 任何单一的字符，除了\n
$ 行的结束位置
^ 行的开始位置
* 量化元，前面字符(或者元)的0个或者多个
+ 量化元，1个或者多个
? 0或者1个
\ 反斜线，转义
[] 匹配中括号中任何一个字符，**只是一个**，[1234],匹配1或者2,或者... 
{} 9{7-8} 匹配9 7到8次
^ 若不是单一出现，如[^gfgf] 就表示反义（反级)
-----  \<  \> 匹配**词**的开始于结束
| 两个表达式进行或运算
[.?!] 匹配标点符号
() 用来分组，() 内的作为一个整体匹配
### 常用词
```
\s 任何空白字符，包括TAB,<br/>等
\b 单词首尾
\w 字母或数字或下划线或汉字
\d 数字
\W 不是\w 的
\S \D \B 都是反义
\n 换行符
[\s\S] 匹配任何字符, . 的升级版，因为. 不匹配\n

### () 内的奥秘
1. (exp)  , 匹配exp ,并将本次匹配的内容保存到自动命名组里面，方便后面通过\1,来调用
如  (fir\w+)\s\1 匹配fir3 fir3 之类，

2. (?<name>exp) 或者(?'name'exp)   ,与前者一样，只是手动命名，通过\k<name> 调用

3. (?:exp)  , 仅匹配exp  的位置，不捕获也不分组号, 实践效果与1一样，只是没有分配组号

4. (?=exp)  零宽断言，匹配exp 前面的位置。 一般卸载整个表达式的后面

5. (?<=exp) ;, exp 后面的位置，一般写在前面

### 贪婪与懒惰

1. 因为匹配总是从文件（字符串）头部开始一直过滤到尾部，匹配总是尽可能多的，这是贪婪的做法
2. 如用(.*?)  先是*匹配0次或者多次. ,后面加了个? ,表明是懒惰做法，即每个匹配的结果尽可能短， 
如， a.*?b 匹配字符串afbdfajjb ,得到， afb ajjb,

[js中 regex教程](https://github.com/alsotang/node-lessons/tree/master/lesson9)
[零宽断言](http://fxck.it/post/50558232873)

1. / /g 全局搜索，而不是只搜索一个就完了
2. / /i 不分大小写
3. / /m 使用^$ 有效
4. 加上g 变量后，正则表达可以作为变量使用如var regex = /h(.*?)\b/g;re.exec('hello hell');
5,有三种写法,/h(.*?)\b/g.exec('hello hell'),/a/.test('A') // => false,'aaa\nbbb\nccc'.match(/^[\s\S]*?$/g) 

```
*?	重复任意次，但尽可能少重复
+?	重复1次或更多次，但尽可能少重复
??	重复0次或1次，但尽可能少重复
{n,m}?	重复n到m次，但尽可能少重复
{n,}?	重复n次以上，但尽可能少重复

```



##### vim 中的正则表达式

在vim中正则极为强大，常用:/s  ':g/  /d' (可匹配后删除) :%s/ / /g 来查找替换，其中 :s/ / / 为严格替换。 

vim中有个magic，可以设定匹配时是否开启加反斜杠，如 /\m 开头的正则表示除了 $ . * ^ 外都要加反斜杠，/\v  任何元字符都不用加入反斜杠。


//                $p = '/[(\w)(=?\:)|(?<=\:).*?(=?,)]/';
//                $p = '/\b\w+(=?:)/';
//                $p = '/(\b\w+?\b):/';
//                $v = preg_replace('/\s/', '', $v);

//                $p = '/(?<=[{|,{|,])(.*?)(:)/';
//                $v = str_replace(, '"$1"', $v);
//                preg_match($p, $v, $m);
//                $f = preg_replace($p, '"$1":', $v);
//                $p = '/(?<=:)(.*?)(?=[}|,])/';
//                $t = preg_replace($p, '"$1"', $f);

