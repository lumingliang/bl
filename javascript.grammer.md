title: javascript 的语法
---
### 基础概念性理解堆和栈
[参考](http://blog.csdn.net/hairetz/article/details/7207230)
1. 堆和栈都是内存，内存本来是统一的，也就没有差别，但是程序的执行，内存的申请，内存的赋值。则是由特定机制处理的，这个机制会把内存分为连续的，不连续的块，cpu要获得某一个内存的值，内容，需要知道它的地址
2. 栈是一块连续的空间，由特定的机制创建，管理和清理，程序员只管写赋值代码等
3. 堆却是非连续的，也就是堆与堆直接，物理上可以不再同一块内存，因为有链表结构的存在，堆储存的信息比栈要多，而且每次申请一个堆，都需要 用new 的方法,在堆没有用处之后，需要程序员手动清理，以防内存泄露。当然js 的垃圾回收机制可以做一些常用的回收内存，但是如果程序设计不当，那么就会造成大量的内存消耗。从而导致程序性能非常低
### js的闭包，作用链，垃圾回收，解释

初级解释。
1. 闭包是内部函数对外部函数的变量引用。
2.	GC机制。如果一个对象不再被引用，那么这个对象就会被GC回收。如果两个对象互相引用，而不再被第三者引用，则这两个都会被回收。函数执行时，会动态申请变量，对象，函数执行完毕后，GC根据规则回收变量，对象所占用的内存

较为成熟解释
1. 作用域，代表着函数或者变量被访问的范围
2. 作用域链，在js中函数也是对象，是对象就会拥有属性，如属性[[scope]],就保存着它能访问的作用域中的所有变量和对象，在函数创建时，scope中只保存着全局变量，对象；当函数执行时，会有运行时作用域对象加入到scope中，并把它推到scope的栈顶端，然后执行该函数里面的语句时，就会从顶端一直往上查找到全局作用域，知道找到该变量为止，这里要注意，每一个函数都有一个独立的scope,这个scope包含了该函数的作用域链，也就是所有能访问的作用域对象的集合，当该函数执行完毕时，它的scope才会被清除，和垃圾回收
```
function add(num1,num2) {
    var sum = num1 + num2;
    return sum;
}
// add在创建时，scope中只有全局作用域对象，在add执行时，会进入（生成一个)活动作用域对象，函数执行的语句根据优先级来向scope中查询变量，引用等

function sayName(name){
    return function(){
        return name;
    }
}
var say = sayName('jozo');

// sayName定义时，sayName只拥有全局作用域对象，
// say执行后，sayName得到执行，sayName将会有一个新的运行时局部作用域(优先级高),say语句之后，(此时sayName执行完毕，属于它的作用域链已经被销毁，但是由于存在var say的引用，所以它的运行时作用域没有被销毁,或者说是传给了匿名函数)返回一个匿名函数，也就是得到一个新的函数，该匿名函数的 scope中包含了全局作用域和sayName的运行时作用域，当执行say()时，匿名函数的scope中又加入了新的自己的运行时作用域，但是由于,存在全局变量say的引用，所以该scope一直保留着
```

```javascript
var oli = document.getElementsByTagName('li');
     var i;
     for(i = 0;i < 5;i++){
         oli[i].onclick = (function(num){
             var a = num; // 为了说明问题
             return function(){
                 alert(a);
             }
         })(i)
     }
     console.log(i); // 5
```
 
[参考](http://segmentfault.com/a/1190000002778015)
[以及更深的解释](http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html)

### 需要理解一下指针和引用

首先声明并初始化一个变量，那么它会得到一块内存，存放着它的地址和值，然后声明一个指向它的指针，那么指针得到的是自己的内存块，里面存放着它自己的地址，它的值是前面那个内存的地址，指针与引用的最主要区别是，利用指针传值时，是对指针的一个复制，而引用传值时，代表的是它本身
```
#include<iostream>
using namespace std;

void test(int *p) //这里传值，*p实际上是一个copy,,有自己的内存，所以对它的改变不会对原来的指针有影响,当然如果是两级指针，那么得到的将是它指向的变量，跟引用一样可以改变了
{
　　int a=1;
　　p=&a;
　　cout<<p<<" "<<*p<<endl;
}

int main(void)
{
    int *p=NULL;
    test(p);
    if(p==NULL)
    cout<<"指针p为NULL"<<endl;
    system("pause");
    return 0;
}
```
### js 的类型

js是一门弱语言，它只有两种类型，一是初始类型，而是引用类型，初始类型存值是直接在栈中进行，引用类型是将一个值或者对象的地址存在当前变量，也可以直接改变它的值，而不像指针那样麻烦

在定义变量时，初始类型有undefined, boolean, number, string, 值直接存在栈中，固定空间，string是存放的它的地址，string是唯一一个可变长度的原始类型

js中一切都是对象，引用类型的都是对象，只是它存放的值是这个对象的地址，母目的是节省内存和适应对象的长度可变性（链表来连接各个小内存块，达到当新增对象里面的属性和方法时，它可以增长长度），这种内存结构叫做堆，而栈是固定的空间，所以只适合存在地址，和一些简单的原始类型

上面说到的string , number 实际上，在js中也是对象，（可以理解有两套，存放时是原始类型，（这是它内存中结构，但是在宏观上看，它就是一个对象，每一个实例都有它的方法和属性）

js中的引用类型（对象）实际上与其他语言的类是逻辑相通的，也就是基本可以看做同一样的东西，既然是对象，就会有属性和方法，js中有一个object对象，所有的对象或者说js里面所有的东西都是继承它得到的，object对象有两个重要属性，一个是constructor,还有就是prototype 

js中的对象可分为两种，一种内置的如object,Funciton,一种实例化出来的，对象的实例和对象都是占据着内存的对空间，只是prototype,和constuctor属性是根据继承关系有所指向的，指向就是指针，指针和引用的区别可以简单理解为，指针不可以直接按常规改变它所指向的对象的值， 但引用可以

理解js的原型链是关键，一定要建立在内存（栈，堆）级别的理解，[栈的执行速度比堆块，因为它是固定的空间，所以不能把堆中的数据放在栈中以免影响速度,而是把堆的地址存放在栈中做一个引用，这样就可以达到以空间换时间的效果，折中],constructor a是b的一个实例，那么a.constuctor指向b ,,, prototype: a.prototype指向a本身
[具体参考,原型链图](http://www.blogjava.net/heavensay/archive/2013/10/20/405440.html)


### js中的面向对象

对象和类，可以先把它当做一个概念，实例就是利用对象（对象构造器）或者类，来生成的有自己独立堆空间的一个新的对象，如实例化两个对象，那么就拥有三个堆空间，一个是原来的类（或者说是对象）； 另外两个是新的对象（实例）；这里每个对象由于其继承关系，都有一个内存的指向关系，原型链

正式因为有prototype, 和constructor这两个对象可以指向它创造函数（对象）的引用，才可以使作用域链的形成，作用域链会在当前没有的时候，搜寻它的prototype,等，所以就可以用到了'外部'的变量对象，虽然是引用，但是引用节省了空间，优化了代码的公用

面向对象的基本要求
1. 封装
2. 聚集，一个对象储存另一个对象的能力
3. 继承
4. 多态，

js中this指针，总是指向调用该方法的对象
```
var oCar = new Object;
oCar.color = "red";
oCar.showColor = function() {
  alert(this.color); // this指向function对象
};

oCar.showColor();		//输出 "red"
```

### 任何软件，设计程序都是需要懂得内存，所以理解了内存，就等于理解了一切

### js中的错误机制
```
function throwit() {
  throw new Error(''); // throw是一个中断程序，抛出一个值，一个对象
}

function catchit() {
  try {
    throwit();
  } catch(e) {
    console.log(e.stack); // print stack trace
  } //try catch可以捕捉到trow抛出的对象或者值
}

catchit()
```


### 下面是一些ES6的新特性
